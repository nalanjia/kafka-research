你好，我是胡夕。今天我要和你分享的主题是：消费者组重平衡全流程解析。

之前我们聊到过消费者组的重平衡流程，它的作用是让组内所有的消费者实例就消费哪些主题分区达成一致。重平衡需要借助 Kafka Broker 端的 Coordinator 组件，在 Coordinator 的帮助下完成整个消费者组的分区重分配。今天我们就来详细说说这个流程。

先提示一下，我会以 Kafka 2.3 版本的源代码开启今天的讲述。在分享的过程中，对于旧版本的设计差异，我也会显式地说明。这样，即使你依然在使用比较旧的版本也不打紧，毕竟设计原理大体上是没有变化的。

触发与通知

我们先来简单回顾一下重平衡的 3 个触发条件：

1。组成员数量发生变化。
2。订阅主题数量发生变化。
3。订阅主题的分区数发生变化。

就我个人的经验来看，在实际生产环境中，因命中第 1 个条件而引发的重平衡是最常见的。另外，消费者组中的消费者实例依次启动也属于第 1 种情况，也就是说，每次消费者组启动时，必然会触发重平衡过程。

这部分内容我在专栏第 15 讲中已经详细介绍过了，就不再赘述了。如果你不记得的话，可以先去复习一下。

今天，我真正想引出的是另一个话题：重平衡过程是如何通知到其他消费者实例的？答案就是，靠消费者端的心跳线程（Heartbeat Thread）。

Kafka Java 消费者需要定期地发送心跳请求（Heartbeat Request）到 Broker 端的协调者，以表明它还存活着。在 Kafka 0.10.1.0 版本之前，发送心跳请求是在消费者主线程完成的，也就是你写代码调用 KafkaConsumer.poll 方法的那个线程。

这样做有诸多弊病，最大的问题在于，消息处理逻辑也是在这个线程中完成的。因此，一旦消息处理消耗了过长的时间，心跳请求将无法及时发到协调者那里，导致协调者“错误地”认为该消费者已“死”。自 0.10.1.0 版本开始，社区引入了一个单独的心跳线程来专门执行心跳请求发送，避免了这个问题。

但这和重平衡又有什么关系呢？其实，重平衡的通知机制正是通过心跳线程来完成的。当协调者决定开启新一轮重平衡后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中，发还给消费者实例。当消费者实例发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就能立马知道重平衡又开始了，这就是重平衡的通知机制。

对了，很多人还搞不清楚消费者端参数 heartbeat.interval.ms 的真实用途，我来解释一下。从字面上看，它就是设置了心跳的间隔时间，但这个参数的真正作用是控制重平衡通知的频率。如果你想要消费者实例更迅速地得到通知，那么就可以给这个参数设置一个非常小的值，这样消费者就能更快地感知到重平衡已经开启了。

消费者组状态机

重平衡一旦开启，Broker 端的协调者组件就要开始忙了，主要涉及到控制消费者组的状态流转。当前，Kafka 设计了一套消费者组状态机（State Machine），来帮助协调者完成整个重平衡流程。严格来说，这套状态机属于非常底层的设计，Kafka 官网上压根就没有提到过，但你最好还是了解一下，因为它能够帮助你搞懂消费者组的设计原理，比如消费者组的过期位移（Expired Offsets）删除等。

目前，Kafka 为消费者组定义了 5 种状态，它们分别是：Empty、Dead、PreparingRebalance、CompletingRebalance 和 Stable。那么，这 5 种状态的含义是什么呢？我们一起来看看下面这张表格。
【3-Kafka为消费者组定义的5种状态.jpeg】

了解了这些状态的含义之后，我们来看一张图片，它展示了状态机的各个状态流转。
【3-配图-状态机的状态流转.png】

我来解释一下消费者组启动时的状态流转过程。一个消费者组最开始是 Empty 状态，当重平衡过程开启后，它会被置于 PreparingRebalance 状态等待成员加入，之后变更到 CompletingRebalance 状态等待分配方案，最后流转到 Stable 状态完成重平衡。

当有新成员加入或已有成员退出时，消费者组的状态从 Stable 直接跳到 PreparingRebalance 状态，此时，所有现存成员就必须重新申请加入组。当所有成员都退出组后，消费者组状态变更为 Empty。Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态。因此，如果你的消费者组停掉了很长时间（超过 7 天），那么 Kafka 很可能就把该组的位移数据删除了。我相信，你在 Kafka 的日志中一定经常看到下面这个输出：

Removed ✘✘✘ expired offsets in ✘✘✘ milliseconds.

这就是 Kafka 在尝试定期删除过期位移。现在你知道了，只有 Empty 状态下的组，才会执行过期位移删除的操作。

消费者端重平衡流程

有了上面的内容作铺垫，我们就可以开始介绍重平衡流程了。重平衡的完整流程需要消费者端和协调者组件共同参与才能完成。我们先从消费者的视角来审视一下重平衡的流程。

在消费者端，重平衡分为两个步骤：分别是加入组和等待领导者消费者（Leader Consumer）分配方案。这两个步骤分别对应两类特定的请求：JoinGroup 请求和 SyncGroup 请求。

当组内成员加入组时，它会向协调者发送 JoinGroup 请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。

通常情况下，第一个发送 JoinGroup 请求的成员自动成为领导者。你一定要注意区分这里的领导者和之前我们介绍的领导者副本，它们不是一个概念。这里的领导者是具体的消费者实例，它既不是副本，也不是协调者。领导者消费者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。

选出领导者之后，协调者会把消费者组订阅信息封装进 JoinGroup 请求的响应体中，然后发给领导者，由领导者统一做出分配方案后，进入到下一步：发送 SyncGroup 请求。

在这一步中，领导者向协调者发送 SyncGroup 请求，将刚刚做出的分配方案发给协调者。值得注意的是，其他成员也会向协调者发送 SyncGroup 请求，只不过请求体中并没有实际的内容。这一步的主要目的是让协调者接收分配方案，然后统一以 SyncGroup 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了。

接下来，我用一张图来形象地说明一下 JoinGroup 请求的处理过程。
【3-配图-JoinGroup请求的处理过程.png】

就像前面说的，JoinGroup 请求的主要作用是将组成员订阅信息发送给领导者消费者，待领导者制定好分配方案后，重平衡流程进入到 SyncGroup 请求阶段。

下面这张图描述的是 SyncGroup 请求的处理流程。
【3-配图-SyncGroup请求的处理流程.png】

SyncGroup 请求的主要目的，就是让协调者把领导者制定的分配方案下发给各个组内成员。当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作。

讲完这里，消费者端的重平衡流程我已经介绍完了。接下来，我们从协调者端来看一下重平衡是怎么执行的。

Broker 端重平衡场景剖析

要剖析协调者端处理重平衡的全流程，我们必须要分几个场景来讨论。这几个场景分别是新成员加入组、组成员主动离组、组成员崩溃离组、组成员提交位移。接下来，我们一个一个来讨论。

场景一：新成员入组。

新成员入组是指组处于 Stable 状态后，有新成员加入。如果是全新启动一个消费者组，Kafka 是有一些自己的小优化的，流程上会有些许的不同。我们这里讨论的是，组稳定了之后有新成员加入的情形。

当协调者收到新的 JoinGroup 请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制它们开启新一轮的重平衡。具体的过程和之前的客户端重平衡流程是一样的。现在，我用一张时序图来说明协调者一端是如何处理新成员入组的。
【3-配图-协调者处理新成员入组.png】

场景二：组成员主动离组。

何谓主动离组？就是指消费者实例所在线程或进程调用 close() 方法主动通知协调者它要退出。这个场景就涉及到了第三类请求：LeaveGroup 请求。协调者收到 LeaveGroup 请求后，依然会以心跳响应的方式通知其他成员，因此我就不再赘述了，还是直接用一张图来说明。
【3-配图-何谓主动离组.png】

场景三：组成员崩溃离组。

崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组。它和主动离组是有区别的，因为后者是主动发起的离组，协调者能马上感知并处理。但崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的。也就是说，Kafka 一般不会超过 session.timeout.ms 就能感知到这个崩溃。当然，后面处理崩溃离组的流程与之前是一样的，我们来看看下面这张图。
【3-配图-崩溃离组.png】

场景四：重平衡时协调者对组内成员提交位移的处理。

正常情况下，每个组内成员都会定期汇报位移给协调者。当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送。还是老办法，我们使用一张图来说明。
【3-配图-重平衡时的协调者.png】

小结

好了，消费者重平衡流程我已经全部讲完了。虽然全程我都是拿两个成员来举例子，但你可以很容易地扩展到多个成员的消费者组，毕竟它们的原理是相同的。我希望你能多看几遍今天的内容，彻底掌握 Kafka 的消费者重平衡流程。社区正在对目前的重平衡流程做较大程度的改动，如果你不了解这些基础的设计原理，后面想深入学习这部分内容的话，会十分困难。
【3-配图-Kafka消费者组重平衡.jpg】

开放讨论

在整个重平衡过程中，组内所有消费者实例都会暂停消费，用 JVM GC 的术语来说就是，重平衡过程是一个 stop the world 操作。请思考一下，针对这个问题，我们该如何改进这个过程？我们是否能允许部分消费者在重平衡过程中继续消费，以提升消费者端的可用性以及吞吐量？

欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。

精选留言(55)


LRocccccc 置顶
是我理解错了么？为什么场景一二三的图中的SyncGroup请求，都是等待Leader分配方案，leader不应该提供方案么？
作者回复: 嗯嗯，确实是。只是目前Kafka要求所有consumer都发送SyncGroup请求给Coordinator，因为分配方案只能通过SyncGroupResponse的方式获取。图中只是想表示这是一种机制，没有太区分consumer leader和其他consumer
2019-08-02



rm -rf 😊ི 置顶
老师，在Broker 端重平衡场景剖析这个第一个图里面，既然协调者说了成员2是这个组的leader，为啥成员2的SyncGroup请求会是”等待leader分配“？这是笔误吗？后面几幅图好像也这样。。。
作者回复: 只是想表明这是统一的一种机制。。。源代码中肯定没有这样的话。。。
2019-07-31



ban
不会超过 session.timeout.ms 就能感知

老师，请问下，消费者已经崩溃了，不会发送心跳，协调者这时候怎么做到能到session.timeout.ms感知的。
作者回复: 每次consumer发送心跳时会顺带发送session timeout时间，这样Coordinator收到后会根据这个session timeout时间计算下次deadline时间，如果过了deadline还没有收到直接fail掉该consumer
2019-08-01


7

Frank
这节课，干货很多，我现在有个疑问，重平衡时需要从消费者实例中选择一个leader，让leader来发起重平衡方案，那为啥不直接让协调者组件来处理呢？
作者回复: 客户端自己确定分配方案有很多好处。比如可以独立演进和上线，不依赖于服务器端
2019-08-06


4

DFighting
重平衡能不能参照JVM中的Minor gc和Major gc，将重平衡分为两步，在资源的角度讲集群进行分区，这里的资源可以理解为分区，因为后两种变化都是涉及到分区——新主题或已有主题的分区数量变化，对于现有的三种重平衡情况分别做如下处理：
1、新成员入区，在当前区内进行重平衡，不要影响其他的分区
2、资源分区中需要消费的分区队列数量发生的变化，也只是涉及到当前分区的重平衡。
这样设计的话就需要处理一个资源分区太空闲和太繁忙时的问题，我觉得可以参考m树的节点分裂和合并，这么做比m树更简单，因为它没有层级关系，只是资源分区的整合和划分而已，实现的时候还能兼顾到网络的局部特性，当然这只是初步想法，没有详细设计和验证，不知道有没有什么地方没有考虑周全，望老师能指点一二。
作者回复: 嗯嗯，非常赞的思路。现在社区正在对rebalance进行改革中有很多思想和你也有重合之处。
2019-09-09


3

明翼
老师有两个问题请教下：
1）组状态在empty的时候，删除位移信息，这个时间间隔（文中7天）是否可以配置那，还是和普通的默认topic的消息存活时间一样吗？
2）这个设计我有点迷糊，都有协调者了为什么不让协调者统一做订阅分配那，让领导者做不是更麻烦吗？
作者回复: 1. 可以配置offsets.retention.minutes
2. 新版本consumer的一个改进就是把分区分配策略从server端移到consumer端来做。Client端代码演进的速度和容易程度要远胜于服务器端，算是一个优势吧
2019-07-30


3

Geek_edc612
胡老师有没有推荐的jvm 书籍？这块一直没有深入看过
作者回复: 我可不敢误人子弟：） 看看R大推荐的书单吧：https://www.douban.com/doulist/2545443/
2019-07-30

1

2

cricket1981
SyncGroup请求处理流程图中怎么出现了JoinGroup请求？是不是笔误？另外，新成员入组流程图中成员2的SyncGroup请求不应该是“协调者你好，我是成员2，也是这个组的领导者，这是我的分配方案...”吗？
作者回复: 感谢纠正，已修改~~
2019-07-30


2

巧克力黑
老师你好，真实场景中遇到如下问题，请教一下。
跑了一整天的数据，同离线数据按小时粒度相比，大部分小时能对齐数据，查看数据对不起的那个小时的消费者日志，发现如下log，
19/10/15 22:46:00 ERROR ConsumerCoordinator: Offset commit failed.
19/10/15 22:46:00 INFO AbstractCoordinator: (Re-)joining group test_group
rebalance会造成数据丢失么？ 是因为这种rebalance造成的数据丢失？
作者回复: 不会造成数据丢失，但可能造成数据重复消费。
2019-10-18


1

巧克力黑
多次执行语句：kafka-consumer-groups.sh --bootstrap-server host1:9092 --describe --group group_v1 
发现CONSUMER-ID一列，有时候只显示"-"，而且每次CONSUMER-ID的值也不相同。是不是就说明发生了重平衡？
作者回复: 显示-是因为消费者有成员没有启动的缘故。另外每次consumer-id不同的确表明每次都是新的member
2019-09-29


1

QQ怪
这一节学到了很多很多，开了视野，感谢
2019-07-30


1

Li Shunduo
请问当重平衡开启时，协调者会给予提交位移的缓冲时间是多少？如果超过了会拒绝提交的位移吗？
作者回复: 没有具体的限制。反正如果consumer提交的位移请求到broker端时整个group已经从Preparing进化到Completing了，那么就晚了，broker会拒绝这个提交请求
2019-07-30


1

Stony.修行僧
有一个问题：Joingroup响应（成员2，你是这组的leader），Syncgroup请求（我是组员2，请求leader分配方案）。成员2已经是leader了，那么syncgroup的请求信息有点费解，明明已经是leader 还要请求leader分配方案？
作者回复: 至少这样能统一机制，因为目前非leader consumer依赖SyncGroup请求才能获取分配方案
2019-07-30


1

pain
文中有一句话：Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态。因此，如果消费者组停掉了很长时间，那么 Kafka 很可能就把该组的位移数据删除了

我记得好像默认 7 天会删除消息的啊，为什么一定要 empty 状态呢？不是 empty 状态，过期的就不删除吗
作者回复: 是的，不是empty就不删除
2019-11-23



James
老师.好像没有说到订阅主题的分区数发生变化.
分区数变化是指broker挂了,或新增吗.
作者回复: 分区数变化是指topic增加了分区
2019-11-13



注定非凡
1 重平衡的通知
A ：重平衡过程通过消息者端的心跳线程（Heartbeat Thread）通知到其他消费者实例。
B ：Kafka Java消费者需要定期地发送心跳请求到Broker端的协调者，以表明它还存活着。
（1）在kafka 0.10.1.0版本之前，发送心跳请求是在消费者主线程完成的，也就是代码中调用KafkaConsumer.poll方法的那个线程。
这样做，消息处理逻辑也是在这个线程中完成的 ，因此，一旦消息处理消耗了过长的时间，心跳请求将无法及时发到协调者那里，导致协调者错判消费者已死。
（2）在此版本后，kafka社区引入了单独的心跳线程来专门执行心跳请求发送，避免这个问题。
C ：重平衡的通知机制是通过心跳线程来完成的，当协调者决定开启新一轮重平衡后，他会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中，发还给消费者实例。当消费者实例发现心跳响应中包含了”REBALANCE_IN_PROGRESS”，就能立即知道重平衡开始了。
D ：消费者端的参数 heartbeat.interval.ms的真实用途是控制重平衡通知的频率。

2 消费者组状态机
Kafka设计了一套消费者组状态机（State Machine），帮助协调者完成整个重平衡流程。
A ：kafka消费者组状态
（1）Empty：组内没有任何成员，但消费者组可能存在已提交的位移数据，而且这些位移尚未过期。
（2）Dead：组内没有任何成员，但组的元数据信息已经在协调者端被移除。协调者保存着当前向它注册过的所有组信息，所谓元数据就是类似于这些注册信息。
（3）PreparingRebalance：消费者组准备开启重平衡，此时所有成员都要重新请求加消费者组
（4）CompletingRebalance：消费者组下所有成员已经加入，各个成员正在等待分配方案。
（5）stable：消费者组的稳定状态。该状态表明重平衡已经完成，组内成员能够正常消费数据了。

       B ：Kafka定期自动删除过期位移的条件就是，组要处于Empty状态。如果消费者组停了很长时间（超过7天），那么Kafka很可能就把该组的位移数据删除了。

3 消费者端重平衡流程
A ：重平衡的完整流程需要消费者端和协调者组件共同参与才能完成。
B ：在消费者端，重平衡分为两个步骤：
（1）加入组，对应请求：JoinGroup请求
（2）等待领导者消费者分配方案：SyncGroup请求
C ：当组内成员加入组时，他会向协调者发送JoinGroup请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了全部成员的JoinGroup请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。
D ：通常情况下，第一个发送JoinGroup 请求的成员自动成为领导者。这里的领导者是具体的消费者实例，它既不是副本，也不是协调者。领导者消费者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。
E ：选出领导者之后，协调者会把消费者组订阅信息封装进JoinGroup请求的响应中，然后发给领导者，由领导统一做出分配方案后，进入下一步：发送SyncGroup请求。
F ：领导者向协调者发送SyncGroup请求，将刚刚做出的分配方案发给协调者。值得注意的是，其他成员也会向协调者发送SyncGroup请求，只是请求体中并没有实际内容。这一步的目的是让协调者接收分配方案，然后统一以SyncGroup 响应的方式发给所有成员，这样组内成员就都知道自己该消费哪些分区了。

4 Broker端重平衡场景剖析

A ：新成员入组
当协调者收到新的JoinGroup请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制他们开启新一轮的重平衡。
B ：组成员主动离组
消费者实例所在线程或进程调用close()方法主动通知协调者他要退出。这个场景涉及第三类请求：LeaveGroup请求。协调者收到LeaveGroup请求后，依然会以心跳响应的方式通知其他成员。
C ：组成员崩溃离组
崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组。崩溃离组是被动的，协调者通常需要等待一段时间才能感知，这段时间一般是由消费者端参数session.timeout.ms控制的。
D ：重平衡时协调者对组内成员提交位移的处理
正常情况下，每个组内成员都会定期汇报位移给协调者。当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后在开启正常JoinGroup/SyncGroup请求发送。
2019-11-08



rhwayfun
线上遇到一个问题，消费组扩容机器100台，直接把broker打挂了，从重平衡的流程看，是因为
2019-11-01



兔2🐰🍃
作者回复: 每次consumer发送心跳时会顺带发送session timeout时间，这样Coordinator收到后会根据这个session timeout时间计算下次deadline时间，如果过了deadline还没有收到直接fail掉该consumer

老师说“Kafka 一般不会超过 session.timeout.ms 就能感知到这个崩溃”，感觉上面回复中的 session timeout 要小于这个消费者端参数，那么心跳请求里的session timeout 是什么计算的？
作者回复: 这块需要更正一次，不是在心跳时携带的session timeout，这个时间在加入组的时候就已经发给Coordinator了。
2019-10-24



绿箭侠
老师，看前面也有人问为啥不把订阅分配方案移到协调者上统一去做？ 您说Client端代码演进速度 和 容易程度远胜于服务器端，是一个优势。
这里还是没明白，为什么Client端代码演进速度 和 容易程度更好？！！
作者回复: 这只是其中的一个可能的原因。client端代码更新的难度要远小于broker端。如果是broker代码更新，你需要rolling upgrade所有集群中的broker，在生产环境中并不一定有这样的时间窗口
2019-10-21



心如大海，春暖花开
消费组状态dead，先提及是组元数据信息被协调者删除，后面又说到协调者保存元数据信息？
作者回复: Dead状态下Coordinator会把组的数据删除。这和后面的表述有什么冲突的地方吗？没太明白您的意思。
2019-10-18



juan
老师有点糊涂，kafka 同一个消费组里面的多个消费者可以有订阅不同的主题？
作者回复: 可以的。同一个组下的不同消费者可以订阅不同的主题
2019-09-25



Andy
请教老师，使用spark streaming直连kafka，如果kafka分区扩展了，spark streaming还能正确处理来自kafka的数据吗
作者回复: 可以的
2019-09-21



AF
老师，很好奇，这些流程原理，您是怎么梳理出来的，看源码吗？
作者回复: 嗯嗯，是的：）
2019-09-13



朱东旭
个人认为可以在消费者组下加入子组，作用类似分段锁，每次仅仅新来的消费者加入子组，仅仅在子组内重平衡。
2019-09-08



电光火石
老师，想问一下：
1. heartbeat.interval.ms和session.timeout.ms 2个参数的差别，在heartbeat.interval.ms达到一定时间没有收到心跳，会引起rebalance，那为什么还需要引入session.timeout.ms 作为客户端崩溃的timeout时间呢，单一用heartbeat.interval.ms不就可以了吗？session.timeout.ms 超时到了还有触发其他的动作吗？另外，heartbeat.interval.ms和session.timeout.ms 都是通过心跳线程来做的吗？
2. “Kafka 定期自动删除过期位移的条件就是，组要处于 Empty状态”，但是我们一直在消费的情况下，比如设置保留7天的数据，我看数据也是会被清理的，不知道是我哪里理解有问题吗？
谢谢了！
作者回复: 1. heartbeat.interval.ms不是用来衡量rebalance的，还是用session.timeout.ms
2. 你指的是消费的数据被删除，那是因为Kafka会自动删除过期日志。我这里说的是Kafka删除过期消费者组位移数据
2019-09-04



roderickyu
老师您好，收到重平衡通知后，如果某个consumer提交位移超时了，那么会造成重复消费吧？是不是只能在应用层去重？
作者回复: 有可能重复。目前用业务去重更保险些
2019-08-26



shenbinzhuo
不同的消费者消费不同的topic主题的领导者都是一个吗，我记得好像不同topic主题的协调者都不是一个啊，老师求解答

作者回复: 一个组对应一个Coordinator，与topic主题无关
2019-08-19



godtrue
白话小结一下
1：消费者组重平衡
1-1：时机——干活的人有变动或者干的活有变动，就需要重新为每个干活者重新分配所干的活。
人员变动——消费者组的成员有变动
活有变动——消费者组消费的主题有变动或者消费者组消费的主题的分区有变动
1-2：方式——协调者类似监工一样，要求干活者每隔一段时间都要报告自己是否还活着，利用这个报告机制可以顺便发起重平衡
1-3：过程——协调者发现人或活有变化了，就发起重平衡的通知，然后每个干活者重新加入分组，协调者让消费者leader来给出一个分活方案，然后按这个方案来分活。
看评论里，老师说“消费者里的消费者可能订阅不同的主题”，我一直的理解是一个消费者组里的消费者只能消费同一个主题下的不同分区，哪请问老师，如果一个消费者组里的消费者可以订阅不同的主题，那那些消费者订阅那些主题，这个怎么分配？感觉有点懵，不知是不是理解有偏差？
2019-08-18



sonald
消费者组的状态是哪端维护的？协调者还是每个消费者都有？我感觉是在协调者端。如果是在协调者端，这个Empty状态是怎么进入的呢。在一个消费者组还没有任何消费者进入时，协调者连group.id都不知道吧。
作者回复: “消费者组的状态是哪端维护的” -- Broker端
2019-08-11



icejoywoo
rebalance的时候需要有leader consumer，如果让coordinator来做leader consumer的工作，计算分配consumer需要的分区，在变更时最小化更改，这样可行么？
作者回复: broker端自行做分配的弊端在于修改一次不容易。不如client端来的方便
2019-08-09



向黎明敬礼
你好老师，请问上面讲SyncGroup是leader会去分配组成员消费哪个分区，下面加入组和离开组的图里画的却是leader去向协调者请求消费哪个组并没有把消费组信息告知协调者是什么原因？
作者回复: leader会通过SyncGroup请求把分配方案发给协调者的
2019-08-08



外星人
你好，之前我们有调整num.network.threads为12，num.io.threads为24，但是还会有request队列满，请问下，这两个参数的比例大概是多少啊？
作者回复: 没有固定比例，调大request队列再试试呢
2019-08-06



杨陆伟
当消费者组中的成员只有一个时，是不是可以将JoinGroup和SyncGroup的请求响应合并，虽然代码逻辑上多了一个分支，但是对于对Kafka小白的应用来说，一个消费者组一个消费者的情况也不少见
作者回复: 感觉合并的好处并没有想象的那么多，那么大。
2019-08-06



杨陆伟
一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者
======这里优点疑问，怎么能确定收集到全部成员的JoinGroup请求呢？如果这点做的不好，就会不断发起重平衡
2019-08-06



外星人
新成员逐个入组，coordinator是如何判断所有的消费成员已经申请入组的呢？
作者回复: 有个超时时间。规定该时间内所有成员都要入组
2019-08-05



LRocccccc
场景一的SyncGroup请求都是等待leader分配方案？成员2不是在JoinGroup时已经告知是Leader了么？
2019-08-02



外星人
你好，我们生产上发现请求队列经常到500，提升了这个参数queued.max.requests到1000略有缓解，但是还是会到1000，集群有七十台左右，cpu负载使用差不多到总核数的70%，请问下
作者回复: 增加num.io.threads试试呢
2019-08-02

1


外星人
你好，我们生产上会经常扩容机器，针对大的topic只能手动reassign，准确性不好，还容易出错，请问下这块有没有好的解决方案啊？
2019-08-02



巧克力黑
老师你好，
订阅主题数量发生变化是指什么？ 怎么才能触发这个场景的发生？
作者回复: consumer.subscribe(Pattern.compile("test.*"))就可以。这样当你新建了一个test开头的topic，订阅信息就发生变化了，需要重新rebalance
2019-08-01

2


ban
老师，这段话“但崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的。也就是说，Kafka 一般不会超过 session.timeout.ms 就能感知到这个崩溃。”

如果我的session.timeout.ms配置了10秒，是不是应该要10秒才能感知这个崩溃。但是我看你的原文“不会超过 session.timeout.ms 就能感知”，好像感觉是说10内就能感知，还没有超时应该不能告知到崩溃了把
作者回复: 最长不会超过10s，也有可能马上就能感知到
2019-08-01



锦
我觉得协调者可以先自己重平衡，然后把结果同步给组成员，如果发现有些成员不在了，再把该成员的数据分配到其他成员
2019-07-31



雨夜听秋的孩子
老师，现需要内网生产消息，公网消费，配置advertise. listeners后生产消息有很长延时，可能是什么原因？
2019-07-31



wykkx
老师请假一个问题：客户端使用spring的组件写入kafka，很短的文本信息，但是报错如下：
WARN [SocketServer brokerId=0] Unexpected error from /192.168.x.x; closing connection (org.apache.kafka.common.network.Selector)
org.apache.kafka.common.network.InvalidReceiveException: Invalid receive (size = 1583156490 larger than 104857600)
不可能超过100M啊
作者回复: 通常可能是因为客户端、服务器端版本不匹配导致的，可以查看一下。
2019-07-31



金hb.Ryan 冷空氣駕到
如果始终有消费，那么过期的消息是不会清理的？这样么
作者回复: 没太懂。。。
2019-07-31



nightmare
重平衡组内位移提交的时候，一定要等到位移提交完成才能发生重平衡吗？ 我觉得是不是可以让分区分区比较多的消费者发生重平衡就行了，保持分区比较少或者压力较小的不发生重平衡，比如在新的消费者加入消费组的时候
2019-07-30

1


Geek_25e177
胡老师，您好，我这里现在碰到这样一个问题，就是在kafka集群开启了认证后，我用客户端的AdminClient去获取所有主题client.listTopics()，需要大概20s左右才能返回结果，如果kafka未开启认证，则返回结果很快，想请教下老师，这有可能是什么原因造成的。

broker配置：
listeners=SASL_PLAINTEXT://host.name:port

security.inter.broker.protocol=SASL_PLAINTEXT

sasl.mechanism.inter.broker.protocol=SCRAM-SHA-512

sasl.enabled.mechanisms=SCRAM-SHA-512

# acl

allow.everyone.if.no.acl.found=false

super.users=User:admin

authorizer.class.name=kafka.security.auth.SimpleAclAuthorizer

client代码：
client.listTopics().names().get()

kafka版本2.1.1
作者回复: 是在windows平台上吗？另外能否看下日志，看看SASL握手的时间是多少，主要是看看慢在哪里了？
2019-07-30

2


Li Shunduo
请问onPartitionsRevoked是在发送JoinGroup请求前触发的吗？
onPartitionsAssigned是在收到SyncGroup响应后触发的吗？
作者回复: onPartitionsRevoked在发送JoinGroup之前；onPartitionsAssigned在收到SyncGroup之后
2019-07-30



许童童
我们是否能允许部分消费者在重平衡过程中继续消费，以提升消费者端的可用性以及吞吐量？
我觉得可以选出领导者，让非领导者继续消费。领导者确定方案后，再让可用的非领导者确定后的方案消费。
2019-07-30



南辕北辙
老师请教一下，在默认情况下，订阅主题的分区数量增加，会自动触发重平衡吗？
作者回复: 会的
2019-07-30



lmtoo
消费者新加入消费者组的时候，JoinGroup必须要携带订阅的主题信息吗？难道不是消费者组里的全部消费者消费一样的主题吗？
还有这个Coordinator组件是针对这个消费者组的，还是全部消费者组的，这个组件在哪个机器上？
控制消费者组位移数据删除时间的参数是哪个？
作者回复: 1. 消费者组里的消费者可能订阅不同的主题
2. 每个Broker上都有一个Coordinator组件，负责部分消费者组的协调工作
3. offsets.retention.minutes
2019-07-30



德惠先生
从java api的源码看，onPartitionsRevoke和onPartitionsAssign并没有办法保证是同一次rebalance过程，因此rebalance过程继续消费的话很容易造成消息重复和数据错乱。老师有啥好方法？
作者回复: 即使没有错乱，因为位移的关系，重复也是不可避免的。最好还是在应用层面去重吧
2019-07-30



cricket1981
为什么要等到session.timeout.ms才感知，而不是heartbeat.interval.ms感知？两者有何区别？
作者回复: 不是。前者顾名思义就是判断session过期与否的，后者是控制心跳线程的发送频率，主要用于控制rebalance通知的频次
2019-07-30



吴宇晨
老师好，如果保持原来的分区分配结果，而不是重新加入组，是不是就可以不用终端消费了
作者回复: 终端消费是指？你是不是说不需要用group帮我分配，我自己分配来消费订阅主题？如果是的话，那么的确，摒弃group是很多框架集成kafka的“标配”了
2019-07-30



青石
老师，从“消费者端重平衡流程”的图1来看，消费者joingroup时，重平衡过程是所以主题都会发生rebalance？还是说只是成员1要消费主题a数据时，只有主题a的消费组会发生rebalance？
作者回复: 和主题关系不大。是同一个消费者组下的所有consumer
2019-07-30



玉剑冰锋
如果是只有empty状态的消费者组才可以执行删除操作，是不是可以说删除位移的操作也触发重平衡？
作者回复: 不会的
2019-07-30

